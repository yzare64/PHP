
نکته:حتما دیزاین پترن را که چطور در لاراول به کار برده شده اند در گوگل سرچ  کنم
کتاب Head First Design Patterns برای دیزاین پترن ها 
در واقع دیزاین پترن ها یک سری روش حل مساله هستند که هر کدومشون یک پیچیدگی را حل میکنند و باعث میشن کار برنامه نویس راحت تر بشه . شما باید با مطالعه کردن اون ها یاد بگیرید که هر کدومشون تو چه مواقعی استفاده میشن و چه کاری رو آسون میکنند .دیزاین پترن ها اصلا وابسته به زبان برنامه نویسی خاصی نیستند و اصلا مهم نیست که شما با چه زبانی دارید کد میزنید . شما فقط باید کاربرد هر کدوم رو بدونید و بدونید چه وقتی از کدوم استفاده کنید . این مهم ترین چیزه . من برای مثال زدن توی آموزش ها از زبان PHP استفاده میکنم ولی شما میتونید با یه سرچ ساده پیاده سازی هر دیزاین پترنی رو داخل هر زبانی پیدا کنید .

 دیزاین پترن ها یا  Design Patterns(راه حل هایی برای حل مشکلات مشابه  یا متدال یا رایج در شی گرایی  که همه تست شده و جواب پس داده اند)Best Practice 
کلا 3 دسته دیزاین پترن داریم
 
1-سازنده creatinal حل مشکلات مربوط به ایجاد اشیا object
2-stractueral  حل مشکلات توسعه پذیری ساختار نرم افزارها و برای مدیریت ارتباط بین کلاس ها و اشیا 
3-behaviral رفتارها مربوط به تعامل و ارتباط اشیا 

 پیشنهاد میکنم  دوره دیزاین پترن ها یکبار ببینید اول کامل دوره رو
و بعد در مورد هر کدوم جداگانه تحقیق کنید و دنبال نمونه کد بگردید.

سایت زیر برای مطالعه دیزاین پترن ها 
https://7learn.com/blog/what-is-design-pattern

مزایای استفاده از دیزاین پترن ها

    افزایش مقیاس پذیری (scalability)
    افزایش قابلیت توسعه پذیری (expandability)
    افزایش انعطاف پذیری (flexibility)
    افزایش سرعت توسعه نرم افزارها
    کاهش خطاها و مشکلات
    کاهش میزان کدنویسی

اینکه بدانیم کی و کجا باید از الگوهای طراحی استفاده کنیم، یکی از سوال‌های رایج در میان برنامه نویسان است. از آنجایی که هر الگوی طراحی برای کاربردی مشخص و حل مشکلی خاص در فرآیند برنامه نویسی ارائه داده شده است، باید بتوانیم آن مشکلات را در زمان توسعه نرم افزار شناسایی کنیم. پس از شناسایی و تشخیص این گونه مشکلات، باید نحوه استفاده از دیزاین پترن‌های ارائه شده برای حل آن‌ها را آموزش ببینیم تا بتوانیم از آن‌ها استفاده کنیم.

app.moqups.com طراحی 

دیزاین پترن استراتژی strategy(رفتاری)که ارتباط مابین آبجکت‌ها را مدیریت می‌کنند.
از این الگو زمانی استفاده میکنیم که بخوایم یه کاری رو به چند روش پیاده سازی کنیم . چند تا مثال میزنم . برای مثال : لاگین کردن کاربر داخل سایت ! لاگین کردن به چندین روش صورت میگیره . مثلا لاگین کردن با ایمیل . لاگین کردن با ارسال کد احراز هویت بوسیله پیامک به کاربر . لاگین کردن با گیت هاب و یا لینکداین . در واقع ما چندین روش رو برای لاگین کردن در نظر میگیرم.

مثال بعدی پیاده سازی درگاه پرداخت هست . مثلا پرداخت با درگاه ملی . پرداخت با درگاه صادرات . پرداخت با درگاه زرین پال و غیره . در واقع ما سیستم پرداخت رو میتونیم به چند روش پیاده سازی کنیم و فقط نمیخایم از یک درگاه استفاده کنیم.
مثال: کلاس هشینگ و کلاس های الگوریتم 

مثال :فرض کنید یه سایت داریم و میخایم هر بار کاربر جدیدی داخل سایت عضو شد به اون خوش آمد بگیم . چند روش داریم ؟

روش اول : خوش آمد گویی با ارسال یک پیامک به شماره تماس کاربر

روش دوم :‌ خوش آمد گویی با ارسال ایمیل خوش آمدگویی به کاربر 

وقتی که ما برای اجرای یک کار مشخص روشهای مختلفی داریم بهترین الگو برای اجرای آن رفتار استراتژی پترن است، برای مثال وقتی ما میخواهیم یک درگاه بانک را پیاده سازی کنیم برای پرداخت مبلغ توسط کابر روش‌های مختلفی وجود دارد برای نمونه: پرداخت انلاین، پرداخت در محل، حواله مبلغ به صورت کارت به کارت یا واریز به حساب انتخاب هر کدام از روش‌ها توسط کاربر صورت میگیرد و در این حالت شرایط وبسایت و نرم افزار تعیین میکند که کاربر کدام روش پرداخت را انتخاب کند مثلا وبسایت ما قابل اعتماد باشد، همه روش‌ها در نرم افزار در دسترس باشد.
حالا وقتی کاربر پرداخت انلاین را انتخاب کند، پرداخت انلاین Providerهای مختلفی دارد و باز در این قسمت نیز ما این الگو را داریم چونکه هر provider به یک نحو امکان پرداخت انلاین را در اختیار ما قرار می‌دهد مثلا API پرداخت بانک ملت و بانک سامان و … باهم تفاوت دارد و از طرفی کاربر خودش پرداخت از کدام بانک را انتخاب می‌کند.

برای پیاده سازی مواد لازم چیه ؟
اول از همه یک Interface لازم داریم . در داخل این اینترفیس استراتژی خودمون رو تعیین میکنیم. بعد به تعداد روش هایی که میخایم پیاده سازی کنیم کلاس ایجاد میکنیم و اون کلاس هارو ملزم میکنیم تا از قانون و اینترفیس ما پیروی کنند و در واقع یک استراتژی واحد را (که همون اینترفیسمونه) رو implement کنن.

توضیحات کاملتر این الگو
https://virgool.io/@sph_1996/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%AF%DB%8C%D8%B2%D8%A7%DB%8C%D9%86-%D9%BE%D8%AA%D8%B1%D9%86-strategy-%D9%88-%D9%BE%DB%8C%D8%A7%D8%AF%D9%87-%D8%B3%D8%A7%D8%B2%DB%8C-%D8%A2%D9%86-%D8%A8%D8%A7-%D9%85%D8%AB%D8%A7%D9%84-w9gcjhcjf4wg
https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%A7%D9%84%DA%AF%D9%88%D9%87%D8%A7%DB%8C-%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C/%D8%A7%D9%84%DA%AF%D9%88%D9%87%D8%A7/%D8%A2%D8%B4%D9%86%D8%A7%DB%8C%DB%8C-%D8%A8%D8%A7-%D8%A7%D9%84%DA%AF%D9%88%DB%8C-%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C-strategy
https://www.developit.ir/design-patterns/strategy-design-pattern.html مرتب سازی داده ها
https://barnamenevisan.org/Articles/Article4696.html
جمع‌بندی
بدین ترتیب نتیجه می‌گیریم در شرایطی که چندین روش برای انجام یک تَسک مشابه یا به عبارتی الگوریتم‌های متعددی برای انجام عملیاتی یکسان وجود دارد، باید یک استراتژی پترن برای این منظور پیاده‌سازی کنیم که با استفاده از این الگو می‌توان به راحتی الگوریتم‌های جدیدی را به سیستم اضافه و یا از آن حذف کرد چرا که این الگوریتم‌ها به سایر کامپوننت‌های سیستم وابسته نبوده و تغییر یا حذف‌شان اختلالی در عملکرد کلی وب اپلیکیشن اِعمال نمی‌کند.
سایت راکت هم مثالی در مورد درگاه پرداخت ها زده و کلیپش در صورت نیاز دیده شود.

در لاراول میتوانیم به سادگی این دیزاین پترن را با Facade پترن ادغام کنیم و نحوه فراخوانی و استفاده از سرویس را آسانتر فراهم کنیم.






دیزاین پترن observer(آبزرو)
 جزو الگو های رفتاری یا Behavioral است یعنی الگوی طراحی Observer به رفتار هایی که در برنامه ی ما اتفاق می افتد مربوط است.
ببینید ساده‌اش این شکلیه ! شما میخوای یه وسیله رو بیاری مغازت بفروشی من، عجله دارم هر ۵ دقیقه میام مغازت ازت میپرسم . حالا اگر افراد دیگه‌ای مثل من باشن که انقدر عجله داشته باشن فکر کن سر اون مغازه چی میاد .
شما این وسط عصبی میشی میگی آقا نیاین چه وضعشه، بهشون میگی یه آدرس پستی بده بهم هر زمان وسیله رو اوردم براتون پستش میکنم اینطوری دیگه بار عجیب غریبی به اون سرور هم اعمال نمیشه!
این دیزاین پترن یه چنین حالی داره. برای حل این مشکل از interface  ها استفاده میکنیم

push vs pull

روش pull  که هر بار کلاینت بیاد و درخواست بده که تغییرات را دریافت کنه بدرد بخور نیست ولی روش push  که کلاینت ها یک بار آیدی رو در سرور میفرستند و سرور ذخیره میکنه و اگر تغییر جدیدی باشه به کلاینت ها میفرسته و این روش خیلی بهینه است

سیستم a  میشه observable  و سیستم b  میشه observer

یا مثال سرور ما  و گیت هاب

اگر بخواهیم در پی اچ پی مقدار هش یک آبجکت را بدست بیاریم از متد یا تایع زیر استفاده میکنیم 
spl_object_hash(object)






دیزاین پترن singleton
 الگوی طراحی سینگلتون از زیر دسته ی creational میباشد یعنی ما یک مسئله برای ساخت objectها داریم که میخواهیم با این الگو طراحی کنیم. 
این الگوی طراحی نرم‌افزار در مواقعی که حداکثر به یک نمونه یا شی یا instance نیاز است استفاده می شود، برای توضیح بهتر از چند مثال واقعی استفاده می‌کنم. مثلا برنامه‌ای داریم که با یک printer کار می‌کند و تنها می‌توان یک instance از connection با printer داشت، در حالی که ممکن است به روش‌ٰهای مختلف و از بخش‌های متفاوتی از برنامه، printer صدا زده شود و نیاز باشد که connection در دسترس قرار گیرد. در اینجا ما می‌توانیم از Singleton Pattern استفاده کنیم که تضمین می‌کند فقط در بار اول یک instance ساخته می‌شود و دفعات بعدی از همان استفاده می‌شود. مثال دیگر می‌تواند برای log زدن در یک برنامه باشد. از هر جای برنامه ممکن هست log زده شود و هر بخشی ممکن است با logger ارتباط برقرار کند،‌ اما اگر همه log ها قرار باشد در یک فایل ذخیره شود و به طور کلی یک logger برای کل برنامه نیاز داشته باشیم، باید این محدودیت در تعداد ساخت instance ایجاد شود وگرنه با هر call، یک instance جدید ساخته می‌شود و به ازای هر log یک object و فایل جدیدی برای ذخیره‌سازی log داریم که اصلا وضعیت مطلوبی نیست و در نتیجه از Singleton Pattern استفاده می‌شود تا یک instance برای log زدن داشته باشیم و در تمام برنامه از آن استفاده شود. ممکن هست که در ارتباط با دیتابیس هم نیاز به Singleton Pattern باشد تا به ازای هر instance یک connection pool جدید ساخته نشود یا مجبور نشویم که برای هر query از connection جدیدی استفاده کنیم. 
کلاس‌های مربوط به کش (Cache) و پیکربندی سیستم اسم برده شده که در صورت نیاز یک نمونه از آنها ساخته می‌شود و در ادامه‌ی روند برنامه از همان نمونه استفاده می‌شود.
یا استفاده از یک پلاگین وردپرسی در پروژه، کافیه یکبار new کند و از امکانات اون کلاس استفاده کند. 
سینگلتون سه ویژگی کلیدی دارد:

    امکان نمونه‌سازی مستقیم از آن وجود ندارد.
    یک نقطه‌ی دسترسی سراسری دارد که نمونه از طریق آن دریافت می‌شود.
    حداکثر یک نمونه ارائه می‌کند.
برای پیاده‌سازی خصوصیت اول، سازنده‌ی کلاس را خصوصی (Private) تعریف می‌کنیم و برای خصوصیت دوم یک متد Static می‌سازیم و خصوصیت سوم را به وسیله‌ی یک شرط مهیا می‌کنیم.برای اطلاعات بیشتر و نحوه استفاده آن در لاراول به سایت زیر مراجعه شود
باید __clone()  و متد serialize__ یا unserialize__  را هم private  کنیم تا نشود نمونه جدید ساخت 

معایب الگوی Singleton

۱. این الگو قانون اول SOLID رو نقض می‌کنه. چرا؟ متد getInstance همزمان دو کار انجام میده. هم مسئول ساختن آبجکت هست و هم مسئول تحویل دادن اون

۲. یک نمونه در سراسر برنامه در دسترس هست و هر قسمتی از برنامه می‌تونه روی این نمونه تاثیر بذاره که باعث میشه عملکرد قسمت‌های دیگه تحت تاثیر قرار بگیره

۳. توی زبان‌های Multi-Thread هنگام ساخته‌شدن آبجکت ممکنه حالت Race Condition به وجود بیاد و در نتیجه چندین نمونه ساخته بشه

۴. Unit تست یک آبجکت Singleton راحت نیست و برای کلاسی که constructor اون private هست و متدهای استاتیک داره، باید به دنبال راه‌های خلاقانه برای ساختن آبجکت Mock باشیم

https://virgool.io/@WebPajooh/singleton-pattern-z8udi3oc5rio
https://virgool.io/@setare.behzadi/%D8%A7%D9%84%DA%AF%D9%88%DB%8C-%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C-%D8%B3%DB%8C%D9%86%DA%AF%D9%84%D8%AA%D9%88%D9%86-singleton-eih3eyookj02
https://ditty.ir/posts/singleton-design-pattern/XNrxX
https://sokanacademy.com/academy/courses/%D8%A2%D9%85%D9%88%D8%B2%D8%B4-%D8%A7%D9%84%DA%AF%D9%88%D9%87%D8%A7%DB%8C-%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C/%D8%A7%D9%84%DA%AF%D9%88%D9%87%D8%A7/%D8%A2%D8%B4%D9%86%D8%A7%DB%8C%DB%8C-%D8%A8%D8%A7-%D8%A7%D9%84%DA%AF%D9%88%DB%8C-%D8%B7%D8%B1%D8%A7%D8%AD%DB%8C-singleton
