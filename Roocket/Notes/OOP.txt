برنامه نویسی تابعی و برنامه نویسی شی گرا
null  با empty  فرق داره 
لایه اعتبارسنجی مهم است validation
اعتبارسنجی html اعتباری ندارد و با novalidate  میتوان اعتبارش را از کار انداخت
خودکار:ویژه گیها:رنگش.سایزش.جنس جوهرش  رفتارش:نوشتن روی برگه
خوانایی-سرعت بالاتر-توسعه پذیر-ارث بری-رفع باگ ها ساده تر شه
در شی گرا کدنویسی بیشتر میشه ولی خب سرعت خوانایی توسعه راحت تر میشه
ساخت سرور مجازی بدون استفاده از زمپ:   php -S localhost:9000 -t foldername
class Pen{}
$pen= new Pen();  یک نمونه یا شی از کلاس Pen میسازه و داخل متغیر pen قرار میده. میتوان بی نهایت شی ساخت.
پراپرتی =خصوصیت=property
public $color='red';
private $color;
protected $color;

var_dump($pen->color); //get
$pen->color='red'; //set

متد یا رفتار 
public or private or protected function save()
{

}

$pen->save();

متغیر جادویی $this: کلمه کلیدی this به شما کمک می‌کند که به شی مورد نظر در داخل کلاس اشاره کنید و به متدها و پروپرتی‌های مختلف داخل کلاس دسترسی داشته باشید.
در phpstorm  برای ساخت متد میتوان pubf را نوشت و سپس tab را زد و ساخته میشه
کامنت نویسی موضوع خیلی مهمی است و با /** میتوان در بالای متد ایجادش کرد .توسعه بهتر کدها و خوانایی در تیم
return is_active===true; 
تابع array_filter(arrayname,function(){} use ()) برای جستجو در لیست یا ارایه
تابع array_shift()  در واقع نتیجه اول را در آرایه برمیگرداند 
property_exists این تابع چک میکنه پراپرتی وجود دارد یا نه
برای مقدار دهی به عناصر یک شی باید مانند کد زیر از {} استفاده کرد                 $this->{$key} = $value;
برای مقدار دهی به عناصر یک آرایه باید از [ ] استفاده کرد 
تابع is_null
شرط shortif  :?  

نکته مهم: در پروژه واقعی باید validation  یا اعتبارسنجی انجام شود 
تابع end  آخرین آیتم از یک لیست رو برمیگردونه 
تابع array_push  آیتم جدید رو به لیست اضافه میکنه 
refactor  خلاصه تر کردن کد مثلا به تابع تبدلیش کنیم 
تابع سازنده _ _ construct
pdo  یک افزونه یا extension یا api  برای mysql و اوراکل وslqlite و ...
برای اینکه pdo در سیستم در php نصب هست یا نه باید به فایل php.ini  رفت و pdo_mysql را فعال کرد
در php 8 میتوان در تابع سازنده پراپرتی ها رو تعریف کرد و دیگه نیازی به تعریف در بیرون تابع سازنده نیست
try{
if(error){
throw new Exception('problem'); اگر خطایی وجود داشت متن رو بفرست به catch  
}
}
catch(Exception $e)
{
}

تابع compact اسم متغییرها رو میگیره و داخل یک آرایه قرار میده با همون اسامی 

const ERROR=1; یک متغیر ثابت ایجاد میکند که همیشه از حروف بزرگ برای تعریف ثابت استفاده میکنیم و علامت $ هم استفاده نمیکنیم 
در واقع متغیر ثابت به دلایل زیر تعریف میکنیم
  تا برای برنامهنویسی جدید هم راحت تر باشد مثلا اگر مقدار 1یا 0 را بخواهیم در کدها به کار ببریم خوانایی ندارد و برای همین از ثابت با نامی مرتبط استفاده میکنیم 
و همچنین برای اینکه در جاهای مختلف استفاده کنیم و یکباره با تغییر ثاابت در همه جا مقدارش تغییر میکند 
برای فراخوانی ثابت نمیخواهد از شی استفاده کنیم بلکه نام کلاس و بعد :: و بعد نام ثابت استفاده میکنیم 
App::ERROR App نام کلاس 

برای اینکه یک کلاس از کلاس دیگر ارث بری کند مانند زیر مینویسیم 
class User extends DB{
}
هر کلاس فقط و فقط میتواند از یک کلاس دیگر ارث بری کند

override دوباره نویسی کردن متد 

parent::__construct() ارث بری کردن  متد سازنده از کلاس پدر 

$this->pdo برای اینکه کلاس فرزند پراپرتی pdo پدر را ارث بری کند 

سطوح دسترسی ها
public شی و  کلاس فرزند میتونه به متدها و پراپرتی ها دسترسی داشته باشه
protected شی نمیتونه دسترسی داشته باشه به متدها و پراپرتی ها ولی کلاس فرزند میتونه 
private فقط و فقط میشه داخل کلاس خودش ازش استفاده کرد و از طریق شی یا کلاس فرزند نمیشه دسترسی داشت 

trim() اسپیس یا فضای خالی دو طرف پاک میکنه


نکته:اگر از die(); استفاده کنیم ادامه کدها اجرا نمیشود .میشه از return  هم استفاده کرد

اعتبارسنجی باید حتما سمت سرور انجام شود که امنیتش بالا هست

array_keys($data); key ها را برمیگرداند
array_values($data); مقادیر را برمیگرداند
join(":",array_keys($data)); key های را با : بهم میچسباند. خروجی رشته بر میگرداند.
array_map(function($item){return ":$item";},array_keys($data))); کی ها رو دونه به دونه پیمایش میکنه و قبل از هر کدام یه : اضافه میکند
ساده سازی تابع که بهش میگم ارو فانکشن fn($item)=>":$item";
روش ساده تر $params = ':' . join( ' , :', array_keys($data));
با implod هم میشه  implode(',',array_keys($data));

متدها و پرارتی های استاتیک 
public static get()
{
}
public static $username;

از طریق شی نمیتوان به متد یا پراپرتی استاتیک دسترسی داشت.
از طریق $this نمیتوان به متد یا پراپرتی استاتیک دسترسی داشت و باید از کلمه کلیدی self  در کلاس و بیرون از کلاس از نام کلاس صدا زده شوند
self::$user;
self::get();
User::$user;
User::get();
در متد استاتیک نمیتوان از $this  استفاده کرد چون در واقع $this به شی ما اشاره میکند و باید از self استفاده کرد

متدهای جادویی magic methods
__ construct متد سازنده یعنی زمانی شی ساخته میشه این تابع اتوماتیک اجرا میشه 
__destruct زمانی که شی حذف میشه این تابع اجرا میشه
unset برای حذف شی یا اندیس آرایه 
__call زمانی که متدی را صدا بزنیم و متد موردنظر وجود نداشته باشد این تابع اتوماتیک اجرا میشود 
__callstatic زمانی که متدی از نوع استاتیک را صدا بزنیم و این متد وجود نداشته باشد این تابع اتوماتیک اجرا میشود
 
اگر بخواهیم در یک متد نوع استاتیک به یک متد یا پراپرتی معمولی دسترسی پیدا کنیم باید به شکل زیر عمل کنیم  و هر سه دستور زیر مانند هم عمل میکنند
return (new User())->get(); یک بار مصرف هس
return (new self)->get();
return (new static())->get();

__tostring با echo نمیتوان یک شی را در خروجی نشان داد و خطا میدهد و برای همین وقتی صدا زده میشود این متد به صورت اتوماتیک اجرا میشود
__invoke  زمانی که بخواهیم شی خود را به شکل یک تابع فراخوانی بکنیم  این تابع  اتوماتیک اجرا میشهاستفاده میشه مثلا var_dump($user("ali"))
__set
__get
__isset
__unset

متدهای زنجیره ای 
$task->task1()->task3()->task2();
در متدهای زنجیره ای همیشه return $this; داریم و به همین دلیل با $this  که بر میگرده میتوانیم به متد ها و پراپرتی ها دسترسی داشته باشیم

متدهای زنجیره ای استاتیک
Task::task1()->task2()->task3();
در متدهای زنجیره ای استاتیک چون نمیتوان از return $this; استفاده کرد باید از return (new static) استفاده کرد که در واقع یک شی از کلاس میسازد 


collection تمرین ساخت مانند لاراول که در واقع از شی گرایی استفاده کنیم
array_merge(array1,array2); ادغام دو آرایه 
اگر بخواهیم تغییرات بر روی شی قبلی اعمال بشه هر بار باید return $this ولی اگر بخواهیم تغییرات بر روی شی جدید اعمال شود از return new static()

دیزاین پترن == الگوهای طراحی برای جلوگیری و ارایه راه حلی برای مشکلات در شی گرایی 
دیزاین پترن facade
class  Collect کلاس فساد
{
    public static  function __callStatic (string  $method,array  $arguments)
    {

        return (new Collection)->$method(...$arguments);

    }
}

namespace برای جلوگیری از تکراری نبودن اسم کلاس ها
اگر در namespace  دو تا نام باشد باید از as  استفاده کنیم برای تغییر نام
کلاس تکراری 
زمانی که یک شی از یک کلاس میسازیم تابع spl_autoload_register صدا زده میشه 
برای اینکه در pure php  یک autoload  استاندارد داشته باشیم باید از سایت https://www.php-fig.org/ بگیریم 
استانداردهای پیشنهادی php  در سایت https://www.php-fig.org/

برای مثال unit test  میتوان از لینک زیر کمک گرفت 
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md

interface قرارداد 

$_REQUEST $_POST و $_GET و cookie  چک میکنه که فیلد مربوط به کدومه
$_SERVER['REQUEST_METHOD']=='POST'
htmlspecialchars اسکریپت یا هر چیزی را به رشته تبدیل میکنه 
array_map('htmlspecialchars',$_POST); کلیه متن ها ورودی را به رشته تبدیل میکنه  خلاصه شده تابع 
array_map('htmlspecialchars',$_GET);

توضیح interface و abstract
در اینترفیس فقط میتوان متد بدون بدنه و از نوع public تعریف کرد و پراپرتی نمیتوان تعریف کرد و همچنین متد یا پراپرتی های معمولی هم نمیتوان تعریف کرد و کلاسی که اینترفیس مورد نظر رو پیاده سازی میکنه باید حتما متدهای تعریف شده را تعریف کنه در خودش. کلاس های فرزند که از پدر خود ارث میبرند نیازی نیست که دوباره متدهای تعریف شده در اینترفیس پدر را تعریف کنند .
در abstract یا طرح یا الگو انتزاعی یا ذهنی وقتی یک کلاس از این نوع تعریف شود دیگر نمیتوان از این کلاس شی ساخت و فقط میتوان از این کلاس ارث بری کرد. میتوان در کلاس از نوع abstract  متدها و پرارتی های معمولی یا بدنه تعریف کرد و همچنین میتوان متد abstract   تعریف کرد که کلاس های فرزند مجبور شوند این متد را در خورد بازنویسی یا override کنند .نمیتوان پراپرتی از نوع abstract ساخت. کلاس های فرزند که از پدر خود ارث میبرند نیازی نیست که دوباره متدهای تعریف شده در اینترفیس پدر را تعریف کنند .
در abstract یا طرح یا الگو انتزاعی یا ذهنی وقتی یک کلاس از این نوع تعریف شود دیگر نمیتوان از این کلاس شی ساخت و فقط میتوان از این کلاس ارث بری کرد. میتوان در 

trait
برای تقسیم بندی کدهای یک کلاس و قابل استفاده کردن کدها در کلاس های دیگر از traits استفاده میشه
چون کلاس ها فقط و فقط میتوانند از یک کلاس ارث بری کنند و زمانی پیش میاد که یه سری کدها باید تکرار شوند و  اینجا نیاز است ا ز trait  استفاده کنیم 
میتوان متدهای trait  را در کلاس بازنویسی کرد 
اگر دو تریت را فراخوانی بکنیم و هر دو تریت یک تابع هم نام داشته باشند خطا به وجود میاد پس باید از insteadofاستفاده کرد و ارجحیت تعیین کرد 
use Searchable,AdvancedSearchable
{
Searchable::search insteadof Advancedable;
}

میتوان نوع دسترسی را تغییر داد مثلا
use Searchable
{
search as protected searchable;
}

میتوان در تریت ها متد abstract  تعریف کرد

برای اطلاعات بیشتر در مورد تریت ها میتوان به سایت php.net  مراجعه کرد 

final class  نمیشه از این کلاس ارث بری کرد و فقط میتوان شی ساخت برعکس abstract  عمل میکند 
{
}
اگر برای یک متد در کلاسی از final  استفاده کنیم نمیتوان آن را بازنویسی کرد 

stdClass  میتوان بدون ساخت کلاسی از این کلمه کلیدی استفاده کرد و شی ساخت  یا برای تعریف یک شی بدون تعریف کلاس
$user=new stdClass(); در واقع یک شی میسازه و میتوان برای این شی پراپرتی تعریف کرد 
$user->name="ali"

میتوان یک شی را درون یک آرایه ریخت 

کلاس های ناشناس مانند همان تابع های ناشناس 
با استفاده از new class{}  میتوان این کلاس ها را ساخت و یجورایی یک بار مصرف هستن 
$user = new User();
$user->show(new class{
//TODO
});

میتوان به جای استفاده از stdClass  برای یک ساخت شی از  new class  استفاده کرد 
$user = new class {};
 کلاس های ناشناس از ورژن پی اچ پی 7 اضافه شدن 

clone  کپی کردن یک شی به شی دیگر 
__clone  این متد جادویی زمانی اجرا میشه به صورت اتوماتیک که در واقع ما یک شی رو با clone  کپی کنیم 

__clone  زمانی که یک شی را بدون clone  اجرا کنیم اجرا نمیشود 


آبجکت را مستقیم نمیتوان در دیتابیس یا فایل ذخیره کرد و برای همین باید از serialize آن را تبدیل به رشته کرد و ذخیره کرد و دوباره میتوان با استفاده از unseialize  به آبجکت تبدیلش کرد
file_put_contents('filename.txt',value); ذخیره در فایل 
file_get_contents('filename.txt'); نمایش محتوای فایل
نکته: زمانی که فایل را unserialize  میکنیم باید کلاس و شی باشد که نتیجه درست نمایش داده بشه 

__serialize و  __unserialize  زمانی که سریال یا آن سریال میکنیم این توابع اجرا میشن اتوماتیک 

مقایسه اینترفیس و abstract
https://ditty.ir/posts/abstract-class-vs-interface/5VVA5





