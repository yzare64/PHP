SOLID (اصول و قواعد پنجگانه برای هر چه بهتر نوشتن کدهای شی گرایی که از قبل امتحان خود را با موفقیت پس داده اند و تست شده هستند
)
اصول سالید سایت ditty هم خوانده شود 

حرف S : برای Single Responsibility Principle
حرف O : برای Open / Closed Principle
حرف L : برای Liskov Substitution Principle
حرف I  : برای Interface Segregation Principle
حرف D : برای ِDependency Inversion Principle

تفاوت SOLID  با Design Patterns =  دیزاین پترن ها در واقع راه حل هایی برای مشکلات مشخص شده هستند ولی SOLID  اصول و قواعد هستند .
هدف SOLID = بالابردن خوانایی کدها -افزایش سرعت توسعه-قابل درکتر-انعطاف پذیر تر

    اکثر الگوهای طراحی (Design Patterns) که وجود دارن، تلاش میکنن اصول سالید رو پیاده‌سازی کنن. مخصوصا اصل اول و دوم.
    برنامه‌های خیلی کمی وجود دارن که همه‌ی این 5 اصل رو همزمان پیاده‌سازی کرده باشن.
    مثل دنیای واقعی، رعایت کردن همه اصول غیر ممکن هست.
    اعمال کردن هر اصل باید با چشم باز انجام بگیره. وگرنه باعث میشه مشکل پیچیده‌تر بشه.
    اصول سالید پای ثابت سوالات مصاحبه هست.

 رفتار یا Behavior مربوط به فعالیت‌هایی میشه که متدها انجام میدن

Single Responsibility Principle
همه وظایف نباید بر دوش یک کلاس یا متد باشه . باید وظایف تقسیم بشه .
مثلا در هر فایل فقط یک کلاس باشه. 
کلاس های پردازش اطلاعات یا ذخیره اطلاعات در دیتابیس یا کلاس خروجی باید از هم جدا شوند و در فایل های جداگانه قرار داده شوند.
رعایت این اصل خوانایی برنامه بالا رفته و افزایش سرعت  توسعه
 
مثلا برای order  مثال بزنیم 
کلاس Order  پردازش اطلاعات سفارش 
کلاس OrderRepository  دخیره اطلاعات سفارش در دیتابیس 
کلاس HtmlOutput  نمایش خروجی سفارش 

open/closed
موجودیت‌های یک نرم‌افزار (کلاس‌ها، ماژول‌ها، توابع و ...) باید برای توسعه داده شدن، باز و برای تغییر دادن، بسته باشن
و میتوان از  interface  استفاده کرد کلاس هایتان را طوری پیاده سازی کنید که برای توسعه دادن باز باشند و برای تغییر بسته باشند 

if(shape instanceof circle) اگر shape  از نوع کلاس circle  باشد 

اصل liskov 
اگر شما دارید از یک کلاسی ارث بری میکنید کلاس فرزند باید بتونه رفتار کلاس پدرش رو انجام بده یعنی در واقع کلاس فرزند نباید متد های کلاس پدر رو override  کنه و این اصل ممکنه در بعضی جاها نقض بشه چون مجبوریم که نقض کنیم 

اصل جداسازی interface
اینترفیس ها رو طوری پیاده سازی کنید که اگر در کلاسی استفاده شدند تمام متدهای آنها مورد استفاده قرار بگیرند اگر متدی مورد استفاده قرار نمیگیرد پس اینترفیس جدا باید برایش پیاده سازی کرد

dependency inversion اصل 
کلاس های سطح بالا نباید وابسته به کلاس های سطح پایین باشند یا ماژول های سطح بالا نباید وابسته به ماژول های سطح پایین باشند مانند کلاس mailer و  smser
 برای این داستان باید از interface  ها استفاده کنیم  

اینکه یه کلاس به خودی خود سطحش بالا هست یا پایین وجود نداره. ما ۲ تا کلاس a و b داریم. اگر از کلاس b در کلاس a استفاده کنیم، کلاس b میشه سطح پایین و کلاس a میشه سطح بالا، و اگر از کلاس a داخل کلاس b استفاده کنیم، کلاس a میشه سطح پایین.
حالا که سطوح مشخص شد، میگیم باید کاری کنیم که کلاس سطح بالا نباید به کلاس سطح پایین وابسطه باشه، این وابستگی رو اومدیم با کلاس واسط یا بهتر بگم یه اینترفیس، از بین بردیم و اومدیم اون کلاس های سطح پایین رو با قواعد اینترفیس پیاده سازی کردیم.

dependency injection دیزاین پترن
برای اینکه اصل dependency inversion  رعایت شود باید از دیزاین پترن dependency injection  استفاده شود



 